<HTML><BODY>
<!-- NEW PAGE -->
<H2><A name="Fl_Tree">class Fl_Tree</A></H2>
<HR>
<H3>Class Hierarchy</H3>
<UL>
<PRE>
<A href="Fl_Group.html#Fl_Group">Fl_Group</A>
   |
   +----<B>Fl_Tree</B>
</PRE>
</UL>
<H3>Include Files</H3>
<UL>
<PRE>
#include &lt;FL/Fl_Tree.H&gt;
</PRE>
</UL>
<H3>Description</H3>
This is the base class for Trees. 
<a href="Fl_Menu_Item.H"><tt>Struct Fl_Menu_Item</tt></a>
array is used as data input. You should subclass it to handle
your specific data structure.

<H3>Methods</H3>
<CENTER>
<TABLE width=90% summary="Fl_Tree methods">
<TR><TD align=left valign=top>
<UL>
<LI><A href="#Fl_Tree.Fl_Tree">Fl_Tree</A></LI>
<LI><A href="#Fl_Tree.~Fl_Tree">~Fl_Tree</A></LI>
<LI><A href="#Fl_Tree.handle">handle</A></LI>
<LI><A href="#Fl_Tree.resize">resize</A></LI>
<LI><A href="#Fl_Tree.draw">draw</A></LI>
<LI><A href="#Fl_Tree.position">position</A></LI>
<LI><A href="#Fl_Tree.hposition">hposition</A></LI>
<LI><A href="#Fl_Tree.value">value</A></LI>
<LI><A href="#Fl_Tree.item_data">item_data</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href="#Fl_Tree.item_max">item_max</A></LI>
<LI><A href="#Fl_Tree.item_draw">item_draw</A></LI>
<LI><A href="#Fl_Tree.item_callback">item_callback</A></LI>
<LI><A href="#Fl_Tree.item_measure">item_measure</A></LI>
<LI><A href="#Fl_Tree.item_nb_children">item_nb_children</A></LI>
<LI><A href="#Fl_Tree.item_get_child">item_get_child</A></LI>
<LI><A href="#Fl_Tree.item_handle">item_handle</A></LI>
<LI><A href="#Fl_Tree.item_open">item_open</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href="#Fl_Tree.item_close">item_close</A></LI>
<LI><A href="#Fl_Tree.item_free">item_free</A></LI>
<LI><A href="#Fl_Tree.item_select">item_select</A></LI>
<LI><A href="#Fl_Tree.item_selected">item_selected</A></LI>
<LI><A href="#Fl_Tree.item_damage">item_damage</A></LI>
<LI><A href="#Fl_Tree.root">root</A></LI>
</UL>
</TD></TR>
</TABLE>
</CENTER>

<H4><A name="Fl_Tree.Fl_Tree">Fl_Tree::Fl_Tree(int, int,
int, int, const char * = 0)</A></H4>

<P>The constructor makes a default Tree widget.


<H4><A name="Fl_Tree.~Fl_Tree">Fl_Tree::~Fl_Tree(void)</A></H4>

<P>The destructor calls <A href="#Fl_Tree.item_free"><TT>item_free()</TT></A>
for all tree items and destroys the Tree.


<H4><A NAME="Fl_Tree.bbox">Fl_Tree::bbox(int &amp;x, int &amp;y, int &amp;w, int &amp;h) const</A></H4>

<P>This method returns the bounding box for the interior of the list, inside
the scrollbars.


<H4><A NAME="Fl_Tree.deleting">Fl_Tree::deleting(void *a)</A></H4>

<P>This method should be used when an item is deleted from the list.
It allows the <TT>Fl_Tree</TT> to discard any cached data it has
on the item.


<H4><A NAME="Fl_Tree.deselect">int Fl_Tree::deselect(int docb=0)</A></H4>

<P>Deselects all items in the list and returns 1 if the state changed
or 0 if it did not.

<P>If <TT>docb</TT> is non-zero, <TT>deselect</TT> tries to call the
callback function for the widget.


<H4><A NAME="Fl_Tree.display">Fl_Tree::display(void *p)</A></H4>

<P>Displays item <TT>p</TT>, scrolling the list as necessary.


<H4><A NAME="Fl_Tree.displayed">int Fl_Tree::displayed(void *p) const</A></H4>

<P>This method returns non-zero if item <TT>p</TT> is currently visible in
the list.


<H4><A NAME="Fl_Tree.draw">Fl_Tree::draw()
<BR>Fl_Tree::draw(int x, int y, int w, int h)</A></H4>

<P>The first form draws the list within the normal widget bounding box.

<P>The second form draws the contents of the browser within the
specified bounding box.


<H4><A NAME="Fl_Tree.find_item">void *Fl_Tree::find_item(int my)</A></H4>

<P>This method returns the item under mouse at <TT>my</TT>. If no item is
displayed at that position then <TT>NULL</TT> is returned.


<H4><A NAME="Fl_Tree.full_height">virtual int Fl_Tree::full_height()</A></H4>

<P>This method may be provided by the subclass to indicate the full height
of the item list in pixels. The default implementation computes the full
height from the item heights.


<H4><A NAME="Fl_Tree.full_width">Fl_Tree::full_width()</A></H4>

<P>This method may be provided by the subclass to indicate the full width
of the item list in pixels. The default implementation computes the full
width from the item widths.


<H4><A NAME="Fl_Tree.handle">Fl_Tree::handle(int event)
<BR>Fl_Tree::handle(int event, int x, int y, int w, int h)</A></H4>

<P>The first form handles an event within the normal widget bounding box.

<P>The second form handles an event within the specified bounding box.


<H4><A name="Fl_Tree.has_scrollbar">void
Fl_Tree::has_scrollbar(int h)</A></H4>

<P>By default you can scroll in both directions, and the scrollbars
disappear if the data will fit in the widget.  has_scrollbar() changes
this based on the value of <TT>h</TT>:

<UL>

	<LI><CODE>0</CODE> - No scrollbars.

	<LI><CODE>Fl_Tree::HORIZONTAL</CODE> - Only a horizontal
	scrollbar.

	<LI><CODE>Fl_Tree::VERTICAL</CODE> - Only a vertical
	scrollbar.

	<LI><CODE>Fl_Tree::BOTH</CODE> - The default is both
	scrollbars.

	<LI><CODE>Fl_Tree::HORIZONTAL_ALWAYS</CODE> - Horizontal
	scrollbar always on, vertical always off.

	<LI><CODE>Fl_Tree::VERTICAL_ALWAYS</CODE> - Vertical
	scrollbar always on, horizontal always off.

	<LI><CODE>Fl_Tree::BOTH_ALWAYS</CODE> - Both always on.

</UL>


<H4><A NAME="Fl_Tree.hposition">int Fl_Tree::hposition() const
<BR>Fl_Tree::hposition(int h)</A></H4>

<P>Gets or sets the horizontal scrolling position of the list.


<H4><A NAME="Fl_Tree.incr_height">virtual int Fl_Tree::incr_height()</A></H4>

<P>This method may be provided to return the average height of all items, to
be used for scrolling. The default implementation uses the height of the first
item.


<H4><A NAME="Fl_Tree.inserting">Fl_Tree::inserting(void *a, void *b)</A></H4>

<P>This method should be used when an item is added to the list.
It allows the <TT>Fl_Tree</TT> to update its cache data as needed.


<H4><A NAME="Fl_Tree.item_draw">virtual void Fl_Tree::item_draw(void *p, int x, int y, int w, int h)</A></H4>

<P>This method must be provided by the subclass to draw the item
<TT>p</TT> in the area indicated by <TT>x</TT>, <TT>y</TT>, <TT>w</TT>,
and <TT>h</TT>.


<H4><A NAME="Fl_Tree.item_first">virtual void *Fl_Tree::item_first() const</A></H4>

<P>This method must be provided by the subclass to return the first item in
the list.


<H4><A NAME="Fl_Tree.item_height">virtual int Fl_Tree::item_height(void *p)</A></H4>

<P>This method must be provided by the subclass to return the height of the
item <TT>p</TT> in pixels.  Allow for two additional pixels for the list
selection box.


<H4><A NAME="Fl_Tree.item_next">virtual void *Fl_Tree::item_next(void *p) const</A></H4>

<P>This method must be provided by the subclass to return the item in
the list after <TT>p</TT>.


<H4><A NAME="Fl_Tree.item_prev">virtual void *Fl_Tree::item_prev(void *p) const</A></H4>

<P>This method must be provided by the subclass to return the item in
the list before <TT>p</TT>.


<H4><A NAME="Fl_Tree.item_quick_height">virtual int Fl_Tree::item_quick_height(void *p)</A></H4>

<P>This method may be provided by the subclass to return the height of the
item <TT>p</TT> in pixels.  Allow for two additional pixels for the list
selection box.  This method differs from
<A HREF="#Fl_Tree.item_height"><TT>item_height</TT></A> in that it is only
called for selection and scrolling operations. The default implementation
calls <TT>item_height</TT>.


<H4><A NAME="Fl_Tree.item_select">virtual void Fl_Tree::item_select(void *p, int s=1)</A></H4>

<P>This method must be implemented by the subclass if it supports
multiple selections in the browser. The <TT>s</TT> argument specifies the
selection state for item <TT>p</TT>: 0 = off, 1 = on.


<H4><A NAME="Fl_Tree.item_selected">virtual int Fl_Tree::item_selected(void *p) const</A></H4>

<P>This method must be implemented by the subclass if it supports
multiple selections in the browser. The method should return 1 if <TT>p</TT>
is selected and 0 otherwise.


<H4><A NAME="Fl_Tree.item_width">virtual int Fl_Tree::item_width(void *p)</A></H4>

<P>This method must be provided by the subclass to return the width of the
item <TT>p</TT> in pixels.  Allow for two additional pixels for the list
selection box.


<H4><A NAME="Fl_Tree.leftedge">int Fl_Tree::leftedge() const</A></H4>

<P>This method returns the X position of the left edge of the list area
after adjusting for the scrollbar and border, if any.


<H4><A NAME="Fl_Tree.new_list">Fl_Tree::new_list()</A></H4>

<P>This method should be called when the list data is completely replaced
or cleared. It informs the <TT>Fl_Tree</TT> widget that any cached
information it has concerning the items is invalid.


<H4><A NAME="Fl_Tree.position">int Fl_Tree::position() const
<BR>Fl_Tree::position(int v) const</A></H4>

<P>Gets or sets the vertical scrolling position of the list.


<H4><A NAME="Fl_Tree.redraw_line">Fl_Tree::redraw_line(void *p)</A></H4>

<P>This method should be called when the contents of an item have changed
but not changed the height of the item.


<H4><A NAME="Fl_Tree.redraw_lines">Fl_Tree::redraw_lines()</A></H4>

<P>This method will cause the entire list to be redrawn.


<H4><A NAME="Fl_Tree.replacing">Fl_Tree::replacing(void *a, void *b)</A></H4>

<P>This method should be used when an item is replaced in the list.
It allows the <TT>Fl_Tree</TT> to update its cache data as needed.


<H4><A NAME="Fl_Tree.resize">Fl_Tree::resize(int x, int y, int w, int h)</A></H4>

<P>Repositions and/or resizes the browser.


<H4><A NAME="Fl_Tree.scrollbar_left">Fl_Tree::scrollbar_left()</A></H4>

<P>This method moves the vertical scrollbar to the lefthand side of the list.


<H4><A NAME="Fl_Tree.scrollbar_right">Fl_Tree::scrollbar_right()</A></H4>

<P>This method moves the vertical scrollbar to the righthand side of the list.


<H4><A NAME="Fl_Tree.select">int Fl_Tree::select(void *p, int s=1, int docb=0)</A></H4>

<P>Sets the selection state of item <TT>p</TT> to <TT>s</TT> and
returns 1 if the state changed or 0 if it did not.

<P>If <TT>docb</TT> is non-zero, <TT>select</TT> tries to call the callback
function for the widget.


<H4><A NAME="Fl_Tree.select_only">Fl_Tree::select_only(void *p, int docb=0)</A></H4>

<P>Selects item <TT>p</TT> and returns 1 if the state changed or 0 if it did
not. Any other items in the list are deselected.

<P>If <TT>docb</TT> is non-zero, <TT>select_only</TT> tries to call the
callback function for the widget.


<H4><A NAME="Fl_Tree.selection">void *Fl_Tree::selection() const</A></H4>

<P>Returns the item currently selected, or NULL if there is no selection.
For multiple selection browsers this call returns the last item that was
selected.


<H4><A name="Fl_Tree.textcolor">Fl_Color Fl_Tree::textcolor() const
<BR>void Fl_Tree::textcolor(Fl_Color color)</A></H4>

<P>The first form gets the default text color for the lines in the
browser.

<P>The second form sets the default text color to <TT>color</TT></P>


<H4><A name="Fl_Tree.textfont">Fl_Font Fl_Tree::textfont() const
<BR>void Fl_Tree::textfont(Fl_Font font)</A></H4>

<P>The first form gets the default text font for the lines in the
browser.

<P>The second form sets the default text font to <TT>font</TT></P>


<H4><A name="Fl_Tree.textsize">uchar Fl_Tree::textsize() const
<BR>void Fl_Tree::textsize(uchar size)</A></H4>

<P>The first form gets the default text size for the lines in the
browser.

<P>The second form sets the default text size to <TT>size</TT></P>


<H4><A NAME="Fl_Tree.top">void *Fl_Tree::top() const</A></H4>

<P>Returns the item the appears at the top of the list.


</BODY>
</HTML>
