<HTML>
<BODY>

<!-- NEW PAGE -->

<H2><A name=Fl_Tile>class Fl_Tile</A></H2>

<HR>

<H3>Class Hierarchy</H3>

<UL><PRE>
<A href=Fl_Group.html#Fl_Group>Fl_Group</A>
   |
   +----<B>Fl_Tile</B>
</PRE></UL>

<H3>Include Files</H3>

<UL><PRE>
#include &lt;FL/Fl_Tile.H&gt;
</PRE></UL>

<H3>Description</H3>

<P>The <TT>Fl_Tile</TT> class lets you resize the children by dragging
the border between them:

<P ALIGN=CENTER><IMG src="Fl_Tile.gif" ALT="Fl_Tile widget."></P>

<P><TT>Fl_Tile</TT> allows objects to be resized to zero dimensions.
To prevent this you can use the <TT>resizable()</TT> to limit where
corners can be dragged to.</P>

<P>Even though objects can be resized to zero sizes, they must
initially have non-zero sizes so the <TT>Fl_Tile</TT> can figure out
their layout. If desired, call <TT>position()</TT> after creating the
children but before displaying the window to set the borders where you
want.</P>

<P>The &quot;borders&quot; are part of the children -
<TT>Fl_Tile</TT> does not draw any graphics of its own. In the
example above, all of the children have <TT>FL_DOWN_BOX</TT>
types, and the &quot;ridges&quot; you see are actually two
adjacent <TT>FL_DOWN_BOX</TT>'s drawn next to each other. All
neighboring widgets share the same edge - the widget's thick
borders make it appear as though the widgets aren't actually
touching, but they are. If the edges of adjacent widgets do not
touch, then it will be impossible to drag the corresponding
edges.</P>

<H3>Methods</H3>
<UL>
<LI><A href=#Fl_Tile.Fl_Tile>Fl_Tile</A></LI>
<LI><A href=#Fl_Tile.~Fl_Tile>~Fl_Tile</A></LI>
<LI><A href=#Fl_Tile.position>position</A></LI>
<LI><A href=#Fl_Tile.resizeable>resizeable</A></LI>
</UL>
<H4><A name=Fl_Tile.Fl_Tile>Fl_Tile::Fl_Tile(int x, int y, int w, int
h, const char *label = 0)</A></H4>
 Creates a new <TT>Fl_Tile</TT> widget using the given position, size,
and label string. The default boxtype is <TT>FL_NO_BOX</TT>.
<H4><A name=Fl_Tile.~Fl_Tile>virtual Fl_Tile::~Fl_Tile()</A></H4>
 The destructor <I>also deletes all the children</I>. This allows a
whole tree to be deleted at once, without having to keep a pointer to
all the children in the user code. A kludge has been done so the <TT>
Fl_Tile</TT> and all of it's children can be automatic (local)
variables, but you must declare the <TT>Fl_Tile</TT> <I>first</I>, so
that it is destroyed last.
<H4><A name=Fl_Tile.position>void Fl_Tile::position(from_x, from_y,
to_x, to_y)</A></H4>
 Drag the intersection at <TT>from_x,from_y</TT> to <TT>to_x,to_y</TT>.
 This redraws all the necessary children.
<H4><A name=Fl_Tile.resizeable>void Fl_Tile::resizable(Fl_Widget &amp;w)<BR>
void Fl_Tile::resizable(Fl_Widget *w)</A></H4>
The &quot;resizable&quot; child widget (which should be invisible) limits where the
border can be dragged to.  If you don't set it, it will be possible to
drag the borders right to the edge, and thus resize objects on the edge
to zero width or height.  The <TT>resizable()</TT> widget is not
resized by dragging any borders.
</BODY></HTML>
